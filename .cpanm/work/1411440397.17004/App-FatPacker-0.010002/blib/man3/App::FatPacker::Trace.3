.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "App::FatPacker::Trace 3"
.TH App::FatPacker::Trace 3 "2013-11-27" "perl v5.20.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
App::FatPacker::Trace \- Tracing module usage using compilation checking
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&    # open STDERR for writing
\&    # will be like: open my $fh, \*(Aq>\*(Aq, \*(Aq&STDERR\*(Aq...
\&    perl \-MApp::FatPacker::Trace=>&STDERR myscript.pl
\&
\&    # open a file for writing
\&    # will be like: open my $fh, \*(Aq>>\*(Aq, \*(Aqfatpacker.trace\*(Aq
\&    perl \-MApp::FatPacker::Trace=>>fatpacker.trace myscript.pl
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module allows tracing the modules being used by your code. It does that
using clever trickery using the \f(CW\*(C`import\*(C'\fR method, the \f(CW\*(C`CHECK\*(C'\fR block and
B's \f(CW\*(C`minus_c\*(C'\fR function.
.PP
When App::FatPacker::Trace is being used, the \fIimport()\fR method will call
\&\f(CW\*(C`B::minus_c\*(C'\fR in order to set up the global compilation-only flag perl
(the interpreter) has. This will prevent any other code from being run.
.PP
Then in the \f(CW\*(C`CHECK\*(C'\fR block which is reached at the end of the compilation
phase (see perlmod), it will gather all modules that have been loaded,
using \f(CW%INC\fR, and will write it to a file or to \s-1STDERR,\s0 determined by
parameters sent to the \f(CW\*(C`import\*(C'\fR method.
.SH "METHODS"
.IX Header "METHODS"
.SS "import"
.IX Subsection "import"
This method gets run when you just load App::FatPacker::Trace. It will
note the current \f(CW%INC\fR and will set up the output to be written to, and
raise the compilation-only flag, which will prevent anything from being
run past that point. This flag cannot be unset, so this is most easily run
from the command line as such:
.PP
.Vb 1
\&    perl \-MApp::FatPacker::Trace [...]
.Ve
.PP
You can control the parameters to the import using an equal sign, as such:
.PP
.Vb 2
\&    # send the parameter "hello"
\&    perl \-MApp::FatPacker::Trace=hello [...]
\&
\&    # send the parameter ">&STDERR"
\&    perl \-MApp::FatPacker::Trace=>&STDERR [...]
.Ve
.PP
The import method accepts a first parameter telling it which output to open
and how. These are both sent in a single parameter.
.PP
.Vb 2
\&    # append to mytrace.txt
\&    perl \-MApp::FatPacker::Trace=>>mytrace.txt myscript.pl
\&
\&    # write to STDERR
\&    perl \-MApp::FatPacker::Trace=>&STDERR myscript.pl
.Ve
.PP
The import method accepts additional parameters of extra modules to load.
It will then add these modules to the trace. This is helpful if you want
to explicitly indicate additional modules to trace, even if they aren't
used in your script. Perhaps you're conditionally using them, perhaps
they're for additional features, perhaps they're loaded lazily, whatever
the reason.
.PP
.Vb 2
\&    # Add Moo to the trace, even if you don\*(Aqt trace it in myscript.pl
\&    perl \-MApp::FatPacker::Trace=>&STDERR,Moo myscript.pl
.Ve
