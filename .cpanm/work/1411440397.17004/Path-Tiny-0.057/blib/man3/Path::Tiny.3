.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Path::Tiny 3"
.TH Path::Tiny 3 "2014-09-19" "perl v5.20.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Path::Tiny \- File path utility
.SH "VERSION"
.IX Header "VERSION"
version 0.057
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Path::Tiny;
\&
\&  # creating Path::Tiny objects
\&
\&  $dir = path("/tmp");
\&  $foo = path("foo.txt");
\&
\&  $subdir = $dir\->child("foo");
\&  $bar = $subdir\->child("bar.txt");
\&
\&  # stringifies as cleaned up path
\&
\&  $file = path("./foo.txt");
\&  print $file; # "foo.txt"
\&
\&  # reading files
\&
\&  $guts = $file\->slurp;
\&  $guts = $file\->slurp_utf8;
\&
\&  @lines = $file\->lines;
\&  @lines = $file\->lines_utf8;
\&
\&  $head = $file\->lines( {count => 1} );
\&
\&  # writing files
\&
\&  $bar\->spew( @data );
\&  $bar\->spew_utf8( @data );
\&
\&  # reading directories
\&
\&  for ( $dir\->children ) { ... }
\&
\&  $iter = $dir\->iterator;
\&  while ( my $next = $iter\->() ) { ... }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provide a small, fast utility for working with file paths.  It is
friendlier to use than File::Spec and provides easy access to functions from
several other core file handling modules.  It aims to be smaller and faster
than many alternatives on \s-1CPAN\s0 while helping people do many common things in
consistent and less error-prone ways.
.PP
Path::Tiny does not try to work for anything except Unix-like and Win32
platforms.  Even then, it might break if you try something particularly obscure
or tortuous.  (Quick!  What does this mean:
\&\f(CW\*(C`///../../..//./././a//b/.././c/././\*(C'\fR?  And how does it differ on Win32?)
.PP
All paths are forced to have Unix-style forward slashes.  Stringifying
the object gives you back the path (after some clean up).
.PP
File input/output methods \f(CW\*(C`flock\*(C'\fR handles before reading or writing,
as appropriate (if supported by the platform).
.PP
The \f(CW*_utf8\fR methods (\f(CW\*(C`slurp_utf8\*(C'\fR, \f(CW\*(C`lines_utf8\*(C'\fR, etc.) operate in raw mode.
On Windows, that means they will not have \s-1CRLF\s0 translation from the \f(CW\*(C`:crlf\*(C'\fR \s-1IO\s0
layer.  Installing Unicode::UTF8 0.58 or later will speed up \f(CW*_utf8\fR
situations in many cases and is highly recommended.
.SH "CONSTRUCTORS"
.IX Header "CONSTRUCTORS"
.SS "path"
.IX Subsection "path"
.Vb 4
\&    $path = path("foo/bar");
\&    $path = path("/tmp", "file.txt"); # list
\&    $path = path(".");                # cwd
\&    $path = path("~user/file.txt");   # tilde processing
.Ve
.PP
Constructs a \f(CW\*(C`Path::Tiny\*(C'\fR object.  It doesn't matter if you give a file or
directory path.  It's still up to you to call directory-like methods only on
directories and file-like methods only on files.  This function is exported
automatically by default.
.PP
The first argument must be defined and have non-zero length or an exception
will be thrown.  This prevents subtle, dangerous errors with code like
\&\f(CW\*(C`path( maybe_undef() )\->remove_tree\*(C'\fR.
.PP
If the first component of the path is a tilde ('~') then the component will be
replaced with the output of \f(CW\*(C`glob(\*(Aq~\*(Aq)\*(C'\fR.  If the first component of the path
is a tilde followed by a user name then the component will be replaced with
output of \f(CW\*(C`glob(\*(Aq~username\*(Aq)\*(C'\fR.  Behaviour for non-existent users depends on
the output of \f(CW\*(C`glob\*(C'\fR on the system.
.PP
On Windows, if the path consists of a drive identifier without a path component
(\f(CW\*(C`C:\*(C'\fR or \f(CW\*(C`D:\*(C'\fR), it will be expanded to the absolute path of the current
directory on that volume using \f(CW\*(C`Cwd::getdcwd()\*(C'\fR.
.PP
If called with a single \f(CW\*(C`Path::Tiny\*(C'\fR argument, the original is returned unless
the original is holding a temporary file or directory reference in which case a
stringified copy is made.
.PP
.Vb 2
\&    $path = path("foo/bar");
\&    $temp = Path::Tiny\->tempfile;
\&
\&    $p2 = path($path); # like $p2 = $path
\&    $t2 = path($temp); # like $t2 = path( "$temp" )
.Ve
.PP
This optimizes copies without proliferating references unexpectedly if a copy is
made by code outside your control.
.SS "new"
.IX Subsection "new"
.Vb 1
\&    $path = Path::Tiny\->new("foo/bar");
.Ve
.PP
This is just like \f(CW\*(C`path\*(C'\fR, but with method call overhead.  (Why would you
do that?)
.SS "cwd"
.IX Subsection "cwd"
.Vb 2
\&    $path = Path::Tiny\->cwd; # path( Cwd::getcwd )
\&    $path = cwd; # optional export
.Ve
.PP
Gives you the absolute path to the current directory as a \f(CW\*(C`Path::Tiny\*(C'\fR object.
This is slightly faster than \f(CW\*(C`path(".")\->absolute\*(C'\fR.
.PP
\&\f(CW\*(C`cwd\*(C'\fR may be exported on request and used as a function instead of as a
method.
.SS "rootdir"
.IX Subsection "rootdir"
.Vb 2
\&    $path = Path::Tiny\->rootdir; # /
\&    $path = rootdir;             # optional export
.Ve
.PP
Gives you \f(CW\*(C`File::Spec\->rootdir\*(C'\fR as a \f(CW\*(C`Path::Tiny\*(C'\fR object if you're too
picky for \f(CW\*(C`path("/")\*(C'\fR.
.PP
\&\f(CW\*(C`rootdir\*(C'\fR may be exported on request and used as a function instead of as a
method.
.SS "tempfile, tempdir"
.IX Subsection "tempfile, tempdir"
.Vb 4
\&    $temp = Path::Tiny\->tempfile( @options );
\&    $temp = Path::Tiny\->tempdir( @options );
\&    $temp = tempfile( @options ); # optional export
\&    $temp = tempdir( @options );  # optional export
.Ve
.PP
\&\f(CW\*(C`tempfile\*(C'\fR passes the options to \f(CW\*(C`File::Temp\->new\*(C'\fR and returns a \f(CW\*(C`Path::Tiny\*(C'\fR
object with the file name.  The \f(CW\*(C`TMPDIR\*(C'\fR option is enabled by default.
.PP
The resulting \f(CW\*(C`File::Temp\*(C'\fR object is cached. When the \f(CW\*(C`Path::Tiny\*(C'\fR object is
destroyed, the \f(CW\*(C`File::Temp\*(C'\fR object will be as well.
.PP
\&\f(CW\*(C`File::Temp\*(C'\fR annoyingly requires you to specify a custom template in slightly
different ways depending on which function or method you call, but
\&\f(CW\*(C`Path::Tiny\*(C'\fR lets you ignore that and can take either a leading template or a
\&\f(CW\*(C`TEMPLATE\*(C'\fR option and does the right thing.
.PP
.Vb 2
\&    $temp = Path::Tiny\->tempfile( "customXXXXXXXX" );             # ok
\&    $temp = Path::Tiny\->tempfile( TEMPLATE => "customXXXXXXXX" ); # ok
.Ve
.PP
The tempfile path object will normalized to have an absolute path, even if
created in a relative directory using \f(CW\*(C`DIR\*(C'\fR.
.PP
\&\f(CW\*(C`tempdir\*(C'\fR is just like \f(CW\*(C`tempfile\*(C'\fR, except it calls
\&\f(CW\*(C`File::Temp\->newdir\*(C'\fR instead.
.PP
Both \f(CW\*(C`tempfile\*(C'\fR and \f(CW\*(C`tempdir\*(C'\fR may be exported on request and used as
functions instead of as methods.
.SH "METHODS"
.IX Header "METHODS"
.SS "absolute"
.IX Subsection "absolute"
.Vb 2
\&    $abs = path("foo/bar")\->absolute;
\&    $abs = path("foo/bar")\->absolute("/tmp");
.Ve
.PP
Returns a new \f(CW\*(C`Path::Tiny\*(C'\fR object with an absolute path (or itself if already
absolute).  Unless an argument is given, the current directory is used as the
absolute base path.  The argument must be absolute or you won't get an absolute
result.
.PP
This will not resolve upward directories (\*(L"foo/../bar\*(R") unless \f(CW\*(C`canonpath\*(C'\fR
in File::Spec would normally do so on your platform.  If you need them
resolved, you must call the more expensive \f(CW\*(C`realpath\*(C'\fR method instead.
.PP
On Windows, an absolute path without a volume component will have it added
based on the current drive.
.SS "append, append_raw, append_utf8"
.IX Subsection "append, append_raw, append_utf8"
.Vb 5
\&    path("foo.txt")\->append(@data);
\&    path("foo.txt")\->append(\e@data);
\&    path("foo.txt")\->append({binmode => ":raw"}, @data);
\&    path("foo.txt")\->append_raw(@data);
\&    path("foo.txt")\->append_utf8(@data);
.Ve
.PP
Appends data to a file.  The file is locked with \f(CW\*(C`flock\*(C'\fR prior to writing.  An
optional hash reference may be used to pass options.  The only option is
\&\f(CW\*(C`binmode\*(C'\fR, which is passed to \f(CW\*(C`binmode()\*(C'\fR on the handle used for writing.
.PP
\&\f(CW\*(C`append_raw\*(C'\fR is like \f(CW\*(C`append\*(C'\fR with a \f(CW\*(C`binmode\*(C'\fR of \f(CW\*(C`:unix\*(C'\fR for fast,
unbuffered, raw write.
.PP
\&\f(CW\*(C`append_utf8\*(C'\fR is like \f(CW\*(C`append\*(C'\fR with a \f(CW\*(C`binmode\*(C'\fR of
\&\f(CW\*(C`:unix:encoding(UTF\-8)\*(C'\fR.  If Unicode::UTF8 0.58+ is installed, a raw
append will be done instead on the data encoded with \f(CW\*(C`Unicode::UTF8\*(C'\fR.
.SS "basename"
.IX Subsection "basename"
.Vb 4
\&    $name = path("foo/bar.txt")\->basename;        # bar.txt
\&    $name = path("foo.txt")\->basename(\*(Aq.txt\*(Aq);    # foo
\&    $name = path("foo.txt")\->basename(qr/.txt/);  # foo
\&    $name = path("foo.txt")\->basename(@suffixes);
.Ve
.PP
Returns the file portion or last directory portion of a path.
.PP
Given a list of suffixes as strings or regular expressions, any that match at
the end of the file portion or last directory portion will be removed before
the result is returned.
.SS "canonpath"
.IX Subsection "canonpath"
.Vb 1
\&    $canonical = path("foo/bar")\->canonpath; # foo\ebar on Windows
.Ve
.PP
Returns a string with the canonical format of the path name for
the platform.  In particular, this means directory separators
will be \f(CW\*(C`\e\*(C'\fR on Windows.
.SS "child"
.IX Subsection "child"
.Vb 2
\&    $file = path("/tmp")\->child("foo.txt"); # "/tmp/foo.txt"
\&    $file = path("/tmp")\->child(@parts);
.Ve
.PP
Returns a new \f(CW\*(C`Path::Tiny\*(C'\fR object relative to the original.  Works
like \f(CW\*(C`catfile\*(C'\fR or \f(CW\*(C`catdir\*(C'\fR from File::Spec, but without caring about
file or directories.
.SS "children"
.IX Subsection "children"
.Vb 2
\&    @paths = path("/tmp")\->children;
\&    @paths = path("/tmp")\->children( qr/\e.txt$/ );
.Ve
.PP
Returns a list of \f(CW\*(C`Path::Tiny\*(C'\fR objects for all files and directories
within a directory.  Excludes \*(L".\*(R" and \*(L"..\*(R" automatically.
.PP
If an optional \f(CW\*(C`qr//\*(C'\fR argument is provided, it only returns objects for child
names that match the given regular expression.  Only the base name is used
for matching:
.PP
.Vb 2
\&    @paths = path("/tmp")\->children( qr/^foo/ );
\&    # matches children like the glob foo*
.Ve
.SS "chmod"
.IX Subsection "chmod"
.Vb 4
\&    path("foo.txt")\->chmod(0777);
\&    path("foo.txt")\->chmod("0755");
\&    path("foo.txt")\->chmod("go\-w");
\&    path("foo.txt")\->chmod("a=r,u+wx");
.Ve
.PP
Sets file or directory permissions.  The argument can be a numeric mode, a
octal string beginning with a \*(L"0\*(R" or a limited subset of the symbolic mode use
by \fI/bin/chmod\fR.
.PP
The symbolic mode must be a comma-delimited list of mode clauses.  Clauses must
match \f(CW\*(C`qr/\eA([augo]+)([=+\-])([rwx]+)\ez/\*(C'\fR, which defines \*(L"who\*(R", \*(L"op\*(R" and
\&\*(L"perms\*(R" parameters for each clause.  Unlike \fI/bin/chmod\fR, all three parameters
are required for each clause, multiple ops are not allowed and permissions
\&\f(CW\*(C`stugoX\*(C'\fR are not supported.  (See File::chmod for more complex needs.)
.SS "copy"
.IX Subsection "copy"
.Vb 1
\&    path("/tmp/foo.txt")\->copy("/tmp/bar.txt");
.Ve
.PP
Copies a file using File::Copy's \f(CW\*(C`copy\*(C'\fR function.
.SS "digest"
.IX Subsection "digest"
.Vb 3
\&    $obj = path("/tmp/foo.txt")\->digest;        # SHA\-256
\&    $obj = path("/tmp/foo.txt")\->digest("MD5"); # user\-selected
\&    $obj = path("/tmp/foo.txt")\->digest( { chunk_size => 1e6 }, "MD5" );
.Ve
.PP
Returns a hexadecimal digest for a file.  An optional hash reference of options may
be given.  The only option is \f(CW\*(C`chunk_size\*(C'\fR.  If \f(CW\*(C`chunk_size\*(C'\fR is given, that many
bytes will be read at a time.  If not provided, the entire file will be slurped
into memory to compute the digest.
.PP
Any subsequent arguments are passed to the constructor for Digest to select
an algorithm.  If no arguments are given, the default is \s-1SHA\-256.\s0
.SS "dirname (deprecated)"
.IX Subsection "dirname (deprecated)"
.Vb 1
\&    $name = path("/tmp/foo.txt")\->dirname; # "/tmp/"
.Ve
.PP
Returns the directory portion you would get from calling
\&\f(CW\*(C`File::Spec\->splitpath( $path\->stringify )\*(C'\fR or \f(CW"."\fR for a path without a
parent directory portion.  Because File::Spec is inconsistent, the result
might or might not have a trailing slash.  Because of this, this method is
\&\fBdeprecated\fR.
.PP
A better, more consistently approach is likely \f(CW\*(C`$path\->parent\->stringify\*(C'\fR,
which will not have a trailing slash except for a root directory.
.SS "exists, is_file, is_dir"
.IX Subsection "exists, is_file, is_dir"
.Vb 3
\&    if ( path("/tmp")\->exists ) { ... }     # \-e
\&    if ( path("/tmp")\->is_dir ) { ... }     # \-d
\&    if ( path("/tmp")\->is_file ) { ... }    # \-e && ! \-d
.Ve
.PP
Implements file test operations, this means the file or directory actually has
to exist on the filesystem.  Until then, it's just a path.
.PP
\&\fBNote\fR: \f(CW\*(C`is_file\*(C'\fR is not \f(CW\*(C`\-f\*(C'\fR because \f(CW\*(C`\-f\*(C'\fR is not the opposite of \f(CW\*(C`\-d\*(C'\fR.
\&\f(CW\*(C`\-f\*(C'\fR means \*(L"plain file\*(R", excluding symlinks, devices, etc. that often can be
read just like files.
.PP
Use \f(CW\*(C`\-f\*(C'\fR instead if you really mean to check for a plain file.
.SS "filehandle"
.IX Subsection "filehandle"
.Vb 2
\&    $fh = path("/tmp/foo.txt")\->filehandle($mode, $binmode);
\&    $fh = path("/tmp/foo.txt")\->filehandle({ locked => 1 }, $mode, $binmode);
.Ve
.PP
Returns an open file handle.  The \f(CW$mode\fR argument must be a Perl-style
read/write mode string (\*(L"<\*(R" ,\*(L">\*(R", \*(L"<<\*(R", etc.).  If a \f(CW$binmode\fR
is given, it is set during the \f(CW\*(C`open\*(C'\fR call.
.PP
An optional hash reference may be used to pass options.  The only option is
\&\f(CW\*(C`locked\*(C'\fR.  If true, handles opened for writing, appending or read-write are
locked with \f(CW\*(C`LOCK_EX\*(C'\fR; otherwise, they are locked with \f(CW\*(C`LOCK_SH\*(C'\fR.  When using
\&\f(CW\*(C`locked\*(C'\fR, \*(L">\*(R" or \*(L"+>\*(R" modes will delay truncation until after the lock is
acquired.
.PP
See \f(CW\*(C`openr\*(C'\fR, \f(CW\*(C`openw\*(C'\fR, \f(CW\*(C`openrw\*(C'\fR, and \f(CW\*(C`opena\*(C'\fR for sugar.
.SS "is_absolute, is_relative"
.IX Subsection "is_absolute, is_relative"
.Vb 2
\&    if ( path("/tmp")\->is_absolute ) { ... }
\&    if ( path("/tmp")\->is_relative ) { ... }
.Ve
.PP
Booleans for whether the path appears absolute or relative.
.SS "is_rootdir"
.IX Subsection "is_rootdir"
.Vb 4
\&    while ( ! $path\->is_rootdir ) {
\&        $path = $path\->parent;
\&        ...
\&    }
.Ve
.PP
Boolean for whether the path is the root directory of the volume.  I.e. the
\&\f(CW\*(C`dirname\*(C'\fR is \f(CW\*(C`q[/]\*(C'\fR and the \f(CW\*(C`basename\*(C'\fR is \f(CW\*(C`q[]\*(C'\fR.
.PP
This works even on \f(CW\*(C`MSWin32\*(C'\fR with drives and \s-1UNC\s0 volumes:
.PP
.Vb 2
\&    path("C:/")\->is_rootdir;             # true
\&    path("//server/share/")\->is_rootdir; #true
.Ve
.SS "iterator"
.IX Subsection "iterator"
.Vb 1
\&    $iter = path("/tmp")\->iterator( \e%options );
.Ve
.PP
Returns a code reference that walks a directory lazily.  Each invocation
returns a \f(CW\*(C`Path::Tiny\*(C'\fR object or undef when the iterator is exhausted.
.PP
.Vb 4
\&    $iter = path("/tmp")\->iterator;
\&    while ( $path = $iter\->() ) {
\&        ...
\&    }
.Ve
.PP
The current and parent directory entries (\*(L".\*(R" and \*(L"..\*(R") will not
be included.
.PP
If the \f(CW\*(C`recurse\*(C'\fR option is true, the iterator will walk the directory
recursively, breadth-first.  If the \f(CW\*(C`follow_symlinks\*(C'\fR option is also true,
directory links will be followed recursively.  There is no protection against
loops when following links. If a directory is not readable, it will not be
followed.
.PP
The default is the same as:
.PP
.Vb 4
\&    $iter = path("/tmp")\->iterator( {
\&        recurse         => 0,
\&        follow_symlinks => 0,
\&    } );
.Ve
.PP
For a more powerful, recursive iterator with built-in loop avoidance, see
Path::Iterator::Rule.
.SS "lines, lines_raw, lines_utf8"
.IX Subsection "lines, lines_raw, lines_utf8"
.Vb 4
\&    @contents = path("/tmp/foo.txt")\->lines;
\&    @contents = path("/tmp/foo.txt")\->lines(\e%options);
\&    @contents = path("/tmp/foo.txt")\->lines_raw;
\&    @contents = path("/tmp/foo.txt")\->lines_utf8;
\&
\&    @contents = path("/tmp/foo.txt")\->lines( { chomp => 1, count => 4 } );
.Ve
.PP
Returns a list of lines from a file.  Optionally takes a hash-reference of
options.  Valid options are \f(CW\*(C`binmode\*(C'\fR, \f(CW\*(C`count\*(C'\fR and \f(CW\*(C`chomp\*(C'\fR.  If \f(CW\*(C`binmode\*(C'\fR
is provided, it will be set on the handle prior to reading.  If \f(CW\*(C`count\*(C'\fR is
provided, up to that many lines will be returned. If \f(CW\*(C`chomp\*(C'\fR is set, any
end-of-line character sequences (\f(CW\*(C`CR\*(C'\fR, \f(CW\*(C`CRLF\*(C'\fR, or \f(CW\*(C`LF\*(C'\fR) will be removed
from the lines returned.
.PP
Because the return is a list, \f(CW\*(C`lines\*(C'\fR in scalar context will return the number
of lines (and throw away the data).
.PP
.Vb 1
\&    $number_of_lines = path("/tmp/foo.txt")\->lines;
.Ve
.PP
\&\f(CW\*(C`lines_raw\*(C'\fR is like \f(CW\*(C`lines\*(C'\fR with a \f(CW\*(C`binmode\*(C'\fR of \f(CW\*(C`:raw\*(C'\fR.  We use \f(CW\*(C`:raw\*(C'\fR
instead of \f(CW\*(C`:unix\*(C'\fR so PerlIO buffering can manage reading by line.
.PP
\&\f(CW\*(C`lines_utf8\*(C'\fR is like \f(CW\*(C`lines\*(C'\fR with a \f(CW\*(C`binmode\*(C'\fR of
\&\f(CW\*(C`:raw:encoding(UTF\-8)\*(C'\fR.  If Unicode::UTF8 0.58+ is installed, a raw
\&\s-1UTF\-8\s0 slurp will be done and then the lines will be split.  This is
actually faster than relying on \f(CW\*(C`:encoding(UTF\-8)\*(C'\fR, though a bit memory
intensive.  If memory use is a concern, consider \f(CW\*(C`openr_utf8\*(C'\fR and
iterating directly on the handle.
.SS "mkpath"
.IX Subsection "mkpath"
.Vb 2
\&    path("foo/bar/baz")\->mkpath;
\&    path("foo/bar/baz")\->mkpath( \e%options );
.Ve
.PP
Like calling \f(CW\*(C`make_path\*(C'\fR from File::Path.  An optional hash reference
is passed through to \f(CW\*(C`make_path\*(C'\fR.  Errors will be trapped and an exception
thrown.  Returns the list of directories created or an empty list if
the directories already exist, just like \f(CW\*(C`make_path\*(C'\fR.
.SS "move"
.IX Subsection "move"
.Vb 1
\&    path("foo.txt")\->move("bar.txt");
.Ve
.PP
Just like \f(CW\*(C`rename\*(C'\fR.
.SS "openr, openw, openrw, opena"
.IX Subsection "openr, openw, openrw, opena"
.Vb 3
\&    $fh = path("foo.txt")\->openr($binmode);  # read
\&    $fh = path("foo.txt")\->openr_raw;
\&    $fh = path("foo.txt")\->openr_utf8;
\&
\&    $fh = path("foo.txt")\->openw($binmode);  # write
\&    $fh = path("foo.txt")\->openw_raw;
\&    $fh = path("foo.txt")\->openw_utf8;
\&
\&    $fh = path("foo.txt")\->opena($binmode);  # append
\&    $fh = path("foo.txt")\->opena_raw;
\&    $fh = path("foo.txt")\->opena_utf8;
\&
\&    $fh = path("foo.txt")\->openrw($binmode); # read/write
\&    $fh = path("foo.txt")\->openrw_raw;
\&    $fh = path("foo.txt")\->openrw_utf8;
.Ve
.PP
Returns a file handle opened in the specified mode.  The \f(CW\*(C`openr\*(C'\fR style methods
take a single \f(CW\*(C`binmode\*(C'\fR argument.  All of the \f(CW\*(C`open*\*(C'\fR methods have
\&\f(CW\*(C`open*_raw\*(C'\fR and \f(CW\*(C`open*_utf8\*(C'\fR equivalents that use \f(CW\*(C`:raw\*(C'\fR and
\&\f(CW\*(C`:raw:encoding(UTF\-8)\*(C'\fR, respectively.
.PP
An optional hash reference may be used to pass options.  The only option is
\&\f(CW\*(C`locked\*(C'\fR.  If true, handles opened for writing, appending or read-write are
locked with \f(CW\*(C`LOCK_EX\*(C'\fR; otherwise, they are locked for \f(CW\*(C`LOCK_SH\*(C'\fR.
.PP
.Vb 1
\&    $fh = path("foo.txt")\->openrw_utf8( { locked => 1 } );
.Ve
.PP
See \*(L"filehandle\*(R" for more on locking.
.SS "parent"
.IX Subsection "parent"
.Vb 2
\&    $parent = path("foo/bar/baz")\->parent; # foo/bar
\&    $parent = path("foo/wibble.txt")\->parent; # foo
\&
\&    $parent = path("foo/bar/baz")\->parent(2); # foo
.Ve
.PP
Returns a \f(CW\*(C`Path::Tiny\*(C'\fR object corresponding to the parent directory of the
original directory or file. An optional positive integer argument is the number
of parent directories upwards to return.  \f(CW\*(C`parent\*(C'\fR by itself is equivalent to
\&\f(CWparent(1)\fR.
.SS "realpath"
.IX Subsection "realpath"
.Vb 2
\&    $real = path("/baz/foo/../bar")\->realpath;
\&    $real = path("foo/../bar")\->realpath;
.Ve
.PP
Returns a new \f(CW\*(C`Path::Tiny\*(C'\fR object with all symbolic links and upward directory
parts resolved using Cwd's \f(CW\*(C`realpath\*(C'\fR.  Compared to \f(CW\*(C`absolute\*(C'\fR, this is
more expensive as it must actually consult the filesystem.
.PP
If the path can't be resolved (e.g. if it includes directories that don't exist),
an exception will be thrown:
.PP
.Vb 1
\&    $real = path("doesnt_exist/foo")\->realpath; # dies
.Ve
.SS "relative"
.IX Subsection "relative"
.Vb 1
\&    $rel = path("/tmp/foo/bar")\->relative("/tmp"); # foo/bar
.Ve
.PP
Returns a \f(CW\*(C`Path::Tiny\*(C'\fR object with a relative path name.
Given the trickiness of this, it's a thin wrapper around
\&\f(CW\*(C`File::Spec\->abs2rel()\*(C'\fR.
.SS "remove"
.IX Subsection "remove"
.Vb 1
\&    path("foo.txt")\->remove;
.Ve
.PP
\&\fBNote: as of 0.012, remove only works on files\fR.
.PP
This is just like \f(CW\*(C`unlink\*(C'\fR, except for its error handling: if the path does
not exist, it returns false; if deleting the file fails, it throws an
exception.
.SS "remove_tree"
.IX Subsection "remove_tree"
.Vb 4
\&    # directory
\&    path("foo/bar/baz")\->remove_tree;
\&    path("foo/bar/baz")\->remove_tree( \e%options );
\&    path("foo/bar/baz")\->remove_tree( { safe => 0 } ); # force remove
.Ve
.PP
Like calling \f(CW\*(C`remove_tree\*(C'\fR from File::Path, but defaults to \f(CW\*(C`safe\*(C'\fR mode.
An optional hash reference is passed through to \f(CW\*(C`remove_tree\*(C'\fR.  Errors will be
trapped and an exception thrown.  Returns the number of directories deleted,
just like \f(CW\*(C`remove_tree\*(C'\fR.
.PP
If you want to remove a directory only if it is empty, use the built-in
\&\f(CW\*(C`rmdir\*(C'\fR function instead.
.PP
.Vb 1
\&    rmdir path("foo/bar/baz/");
.Ve
.SS "slurp, slurp_raw, slurp_utf8"
.IX Subsection "slurp, slurp_raw, slurp_utf8"
.Vb 4
\&    $data = path("foo.txt")\->slurp;
\&    $data = path("foo.txt")\->slurp( {binmode => ":raw"} );
\&    $data = path("foo.txt")\->slurp_raw;
\&    $data = path("foo.txt")\->slurp_utf8;
.Ve
.PP
Reads file contents into a scalar.  Takes an optional hash reference may be
used to pass options.  The only option is \f(CW\*(C`binmode\*(C'\fR, which is passed to
\&\f(CW\*(C`binmode()\*(C'\fR on the handle used for reading.
.PP
\&\f(CW\*(C`slurp_raw\*(C'\fR is like \f(CW\*(C`slurp\*(C'\fR with a \f(CW\*(C`binmode\*(C'\fR of \f(CW\*(C`:unix\*(C'\fR for
a fast, unbuffered, raw read.
.PP
\&\f(CW\*(C`slurp_utf8\*(C'\fR is like \f(CW\*(C`slurp\*(C'\fR with a \f(CW\*(C`binmode\*(C'\fR of
\&\f(CW\*(C`:unix:encoding(UTF\-8)\*(C'\fR.  If Unicode::UTF8 0.58+ is installed, a raw
slurp will be done instead and the result decoded with \f(CW\*(C`Unicode::UTF8\*(C'\fR.
This is just as strict and is roughly an order of magnitude faster than
using \f(CW\*(C`:encoding(UTF\-8)\*(C'\fR.
.SS "spew, spew_raw, spew_utf8"
.IX Subsection "spew, spew_raw, spew_utf8"
.Vb 5
\&    path("foo.txt")\->spew(@data);
\&    path("foo.txt")\->spew(\e@data);
\&    path("foo.txt")\->spew({binmode => ":raw"}, @data);
\&    path("foo.txt")\->spew_raw(@data);
\&    path("foo.txt")\->spew_utf8(@data);
.Ve
.PP
Writes data to a file atomically.  The file is written to a temporary file in
the same directory, then renamed over the original.  An optional hash reference
may be used to pass options.  The only option is \f(CW\*(C`binmode\*(C'\fR, which is passed to
\&\f(CW\*(C`binmode()\*(C'\fR on the handle used for writing.
.PP
\&\f(CW\*(C`spew_raw\*(C'\fR is like \f(CW\*(C`spew\*(C'\fR with a \f(CW\*(C`binmode\*(C'\fR of \f(CW\*(C`:unix\*(C'\fR for a fast,
unbuffered, raw write.
.PP
\&\f(CW\*(C`spew_utf8\*(C'\fR is like \f(CW\*(C`spew\*(C'\fR with a \f(CW\*(C`binmode\*(C'\fR of \f(CW\*(C`:unix:encoding(UTF\-8)\*(C'\fR.
If Unicode::UTF8 0.58+ is installed, a raw spew will be done instead on
the data encoded with \f(CW\*(C`Unicode::UTF8\*(C'\fR.
.SS "stat, lstat"
.IX Subsection "stat, lstat"
.Vb 2
\&    $stat = path("foo.txt")\->stat;
\&    $stat = path("/some/symlink")\->lstat;
.Ve
.PP
Like calling \f(CW\*(C`stat\*(C'\fR or \f(CW\*(C`lstat\*(C'\fR from File::stat.
.SS "stringify"
.IX Subsection "stringify"
.Vb 2
\&    $path = path("foo.txt");
\&    say $path\->stringify; # same as "$path"
.Ve
.PP
Returns a string representation of the path.  Unlike \f(CW\*(C`canonpath\*(C'\fR, this method
returns the path standardized with Unix-style \f(CW\*(C`/\*(C'\fR directory separators.
.SS "subsumes"
.IX Subsection "subsumes"
.Vb 2
\&    path("foo/bar")\->subsumes("foo/bar/baz"); # true
\&    path("/foo/bar")\->subsumes("/foo/baz");   # false
.Ve
.PP
Returns true if the first path is a prefix of the second path at a directory
boundary.
.PP
This \fBdoes not\fR resolve parent directory entries (\f(CW\*(C`..\*(C'\fR) or symlinks:
.PP
.Vb 1
\&    path("foo/bar")\->subsumes("foo/bar/../baz"); # true
.Ve
.PP
If such things are important to you, ensure that both paths are resolved to
the filesystem with \f(CW\*(C`realpath\*(C'\fR:
.PP
.Vb 3
\&    my $p1 = path("foo/bar")\->realpath;
\&    my $p2 = path("foo/bar/../baz")\->realpath;
\&    if ( $p1\->subsumes($p2) ) { ... }
.Ve
.SS "touch"
.IX Subsection "touch"
.Vb 2
\&    path("foo.txt")\->touch;
\&    path("foo.txt")\->touch($epoch_secs);
.Ve
.PP
Like the Unix \f(CW\*(C`touch\*(C'\fR utility.  Creates the file if it doesn't exist, or else
changes the modification and access times to the current time.  If the first
argument is the epoch seconds then it will be used.
.PP
Returns the path object so it can be easily chained with spew:
.PP
.Vb 1
\&    path("foo.txt")\->touch\->spew( $content );
.Ve
.SS "touchpath"
.IX Subsection "touchpath"
.Vb 1
\&    path("bar/baz/foo.txt")\->touchpath;
.Ve
.PP
Combines \f(CW\*(C`mkpath\*(C'\fR and \f(CW\*(C`touch\*(C'\fR.  Creates the parent directory if it doesn't exist,
before touching the file.  Returns the path object like \f(CW\*(C`touch\*(C'\fR does.
.SS "volume"
.IX Subsection "volume"
.Vb 2
\&    $vol = path("/tmp/foo.txt")\->volume;   # ""
\&    $vol = path("C:/tmp/foo.txt")\->volume; # "C:"
.Ve
.PP
Returns the volume portion of the path.  This is equivalent
equivalent to what File::Spec would give from \f(CW\*(C`splitpath\*(C'\fR and thus
usually is the empty string on Unix-like operating systems or the
drive letter for an absolute path on \f(CW\*(C`MSWin32\*(C'\fR.
.SH "EXCEPTION HANDLING"
.IX Header "EXCEPTION HANDLING"
Simple usage errors will generally croak.  Failures of underlying Perl
unctions will be thrown as exceptions in the class
\&\f(CW\*(C`Path::Tiny::Error\*(C'\fR.
.PP
A \f(CW\*(C`Path::Tiny::Error\*(C'\fR object will be a hash reference with the following fields:
.IP "\(bu" 4
\&\f(CW\*(C`op\*(C'\fR X a description of the operation, usually function call and any extra info
.IP "\(bu" 4
\&\f(CW\*(C`file\*(C'\fR X the file or directory relating to the error
.IP "\(bu" 4
\&\f(CW\*(C`err\*(C'\fR X hold \f(CW$!\fR at the time the error was thrown
.IP "\(bu" 4
\&\f(CW\*(C`msg\*(C'\fR X a string combining the above data and a Carp-like short stack trace
.PP
Exception objects will stringify as the \f(CW\*(C`msg\*(C'\fR field.
.SH "CAVEATS"
.IX Header "CAVEATS"
.SS "File locking"
.IX Subsection "File locking"
If flock is not supported on a platform, it will not be used, even if
locking is requested.
.PP
See additional caveats below.
.PP
\fI\s-1NFS\s0 and \s-1BSD\s0\fR
.IX Subsection "NFS and BSD"
.PP
On \s-1BSD,\s0 Perl's flock implementation may not work to lock files on an
\&\s-1NFS\s0 filesystem.  Path::Tiny has some heuristics to detect this
and will warn once and let you continue in an unsafe mode.  If you
want this failure to be fatal, you can fatalize the 'flock' warnings
category:
.PP
.Vb 1
\&    use warnings FATAL => \*(Aqflock\*(Aq;
.Ve
.PP
\fI\s-1AIX\s0 and locking\fR
.IX Subsection "AIX and locking"
.PP
\&\s-1AIX\s0 requires a write handle for locking.  Therefore, calls that normally
open a read handle and take a shared lock instead will open a read-write
handle and take an exclusive lock.  If the user does not have write
permission, no lock will be used.
.SS "utf8 vs \s-1UTF\-8\s0"
.IX Subsection "utf8 vs UTF-8"
All the \f(CW*_utf8\fR methods use \f(CW\*(C`:encoding(UTF\-8)\*(C'\fR \*(-- either as
\&\f(CW\*(C`:unix:encoding(UTF\-8)\*(C'\fR (unbuffered) or \f(CW\*(C`:raw:encoding(UTF\-8)\*(C'\fR (buffered) \*(--
which is strict against the Unicode spec and disallows illegal Unicode
codepoints or \s-1UTF\-8\s0 sequences.
.PP
Unfortunately, \f(CW\*(C`:encoding(UTF\-8)\*(C'\fR is very, very slow.  If you install
Unicode::UTF8 0.58 or later, that module will be used by some \f(CW*_utf8\fR
methods to encode or decode data after a raw, binary input/output operation,
which is much faster.
.PP
If you need the performance and can accept the security risk,
\&\f(CW\*(C`slurp({binmode => ":unix:utf8"})\*(C'\fR will be faster than \f(CW\*(C`:unix:encoding(UTF\-8)\*(C'\fR
(but not as fast as \f(CW\*(C`Unicode::UTF8\*(C'\fR).
.PP
Note that the \f(CW*_utf8\fR methods read in \fBraw\fR mode.  There is no \s-1CRLF\s0
translation on Windows.  If you must have \s-1CRLF\s0 translation, use the regular
input/output methods with an appropriate binmode:
.PP
.Vb 2
\&  $path\->spew_utf8($data);                            # raw
\&  $path\->spew({binmode => ":encoding(UTF\-8)"}, $data; # LF \-> CRLF
.Ve
.PP
Consider PerlIO::utf8_strict for a faster PerlIO layer alternative to
\&\f(CW\*(C`:encoding(UTF\-8)\*(C'\fR, though it does not appear to be as fast as the
\&\f(CW\*(C`Unicode::UTF8\*(C'\fR approach.
.SS "Default \s-1IO\s0 layers and the open pragma"
.IX Subsection "Default IO layers and the open pragma"
If you have Perl 5.10 or later, file input/output methods (\f(CW\*(C`slurp\*(C'\fR, \f(CW\*(C`spew\*(C'\fR,
etc.) and high-level handle opening methods ( \f(CW\*(C`filehandle\*(C'\fR, \f(CW\*(C`openr\*(C'\fR,
\&\f(CW\*(C`openw\*(C'\fR, etc. ) respect default encodings set by the \f(CW\*(C`\-C\*(C'\fR switch or lexical
open settings of the caller.  For \s-1UTF\-8,\s0 this is almost certainly slower
than using the dedicated \f(CW\*(C`_utf8\*(C'\fR methods if you have Unicode::UTF8.
.SH "TYPE CONSTRAINTS AND COERCION"
.IX Header "TYPE CONSTRAINTS AND COERCION"
A standard MooseX::Types library is available at
MooseX::Types::Path::Tiny.  A Type::Tiny equivalent is available as
Types::Path::Tiny.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
These are other file/path utilities, which may offer a different feature
set than \f(CW\*(C`Path::Tiny\*(C'\fR.
.IP "\(bu" 4
File::chmod
.IP "\(bu" 4
File::Fu
.IP "\(bu" 4
IO::All
.IP "\(bu" 4
Path::Class
.PP
These iterators may be slightly faster than the recursive iterator in
\&\f(CW\*(C`Path::Tiny\*(C'\fR:
.IP "\(bu" 4
Path::Iterator::Rule
.IP "\(bu" 4
File::Next
.PP
There are probably comparable, non-Tiny tools.  Let me know if you want me to
add a module to the list.
.PP
This module was featured in the 2013 Perl Advent Calendar <http://www.perladvent.org/2013/2013-12-18.html>.
.SH "SUPPORT"
.IX Header "SUPPORT"
.SS "Bugs / Feature Requests"
.IX Subsection "Bugs / Feature Requests"
Please report any bugs or feature requests through the issue tracker
at <https://github.com/dagolden/Path\-Tiny/issues>.
You will be notified automatically of any progress on your issue.
.SS "Source Code"
.IX Subsection "Source Code"
This is open source software.  The code repository is available for
public review and contribution under the terms of the license.
.PP
<https://github.com/dagolden/Path\-Tiny>
.PP
.Vb 1
\&  git clone https://github.com/dagolden/Path\-Tiny.git
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
David Golden <dagolden@cpan.org>
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
.IP "\(bu" 4
Chris Williams <bingos@cpan.org>
.IP "\(bu" 4
Michael G. Schwern <mschwern@cpan.org>
.IP "\(bu" 4
Smylers <Smylers@stripey.com>
.IP "\(bu" 4
Toby Inkster <tobyink@cpan.org>
.IP "\(bu" 4
\&\s-1XXX \-\s0 Keedi Kim <keedi@cpan.org>
.IP "\(bu" 4
David Steinbrunner <dsteinbrunner@pobox.com>
.IP "\(bu" 4
Doug Bell <madcityzen@gmail.com>
.IP "\(bu" 4
Gabor Szabo <szabgab@cpan.org>
.IP "\(bu" 4
Gabriel Andrade <gabiruh@gmail.com>
.IP "\(bu" 4
George Hartzell <hartzell@cpan.org>
.IP "\(bu" 4
Geraud Continsouzas <geraud@scsi.nc>
.IP "\(bu" 4
Goro Fuji <gfuji@cpan.org>
.IP "\(bu" 4
Karen Etheridge <ether@cpan.org>
.IP "\(bu" 4
Martin Kjeldsen <mk@bluepipe.dk>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is Copyright (c) 2013 by David Golden.
.PP
This is free software, licensed under:
.PP
.Vb 1
\&  The Apache License, Version 2.0, January 2004
.Ve
