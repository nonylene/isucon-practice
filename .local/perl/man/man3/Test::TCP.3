.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Test::TCP 3"
.TH Test::TCP 3 "2014-07-01" "perl v5.20.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Test::TCP \- testing TCP program
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Test::TCP;
\&
\&    my $server = Test::TCP\->new(
\&        code => sub {
\&            my $port = shift;
\&            ...
\&        },
\&    );
\&    my $client = MyClient\->new(host => \*(Aq127.0.0.1\*(Aq, port => $server\->port);
\&    undef $server; # kill child process on DESTROY
.Ve
.PP
Using memcached:
.PP
.Vb 1
\&    use Test::TCP;
\&
\&    my $memcached = Test::TCP\->new(
\&        code => sub {
\&            my $port = shift;
\&
\&            exec $bin, \*(Aq\-p\*(Aq => $port;
\&            die "cannot execute $bin: $!";
\&        },
\&    );
\&    my $memd = Cache::Memcached\->new({servers => [\*(Aq127.0.0.1:\*(Aq . $memcached\->port]});
\&    ...
.Ve
.PP
And functional interface is available:
.PP
.Vb 11
\&    use Test::TCP;
\&    test_tcp(
\&        client => sub {
\&            my ($port, $server_pid) = @_;
\&            # send request to the server
\&        },
\&        server => sub {
\&            my $port = shift;
\&            # run server
\&        },
\&    );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Test::TCP is test utilities for \s-1TCP/IP\s0 programs.
.SH "METHODS"
.IX Header "METHODS"
.IP "test_tcp" 4
.IX Item "test_tcp"
Functional interface.
.Sp
.Vb 10
\&    test_tcp(
\&        client => sub {
\&            my $port = shift;
\&            # send request to the server
\&        },
\&        server => sub {
\&            my $port = shift;
\&            # run server
\&        },
\&        # optional
\&        port => 8080,
\&        max_wait => 3, # seconds
\&    );
.Ve
.IP "wait_port" 4
.IX Item "wait_port"
.Vb 1
\&    wait_port(8080);
.Ve
.Sp
Waits for a particular port is available for connect.
.SH "OO-ish interface"
.IX Header "OO-ish interface"
.ie n .IP "my $server = Test::TCP\->new(%args);" 4
.el .IP "my \f(CW$server\fR = Test::TCP\->new(%args);" 4
.IX Item "my $server = Test::TCP->new(%args);"
Create new instance of Test::TCP.
.Sp
Arguments are following:
.RS 4
.ie n .IP "$args{auto_start}: Boolean" 4
.el .IP "\f(CW$args\fR{auto_start}: Boolean" 4
.IX Item "$args{auto_start}: Boolean"
Call \f(CW\*(C`$server\->start()\*(C'\fR after create instance.
.Sp
Default: true
.ie n .IP "$args{code}: CodeRef" 4
.el .IP "\f(CW$args\fR{code}: CodeRef" 4
.IX Item "$args{code}: CodeRef"
The callback function. Argument for callback function is: \f(CW\*(C`$code\->($pid)\*(C'\fR.
.Sp
This parameter is required.
.ie n .IP "$args{max_wait} : Number" 4
.el .IP "\f(CW$args\fR{max_wait} : Number" 4
.IX Item "$args{max_wait} : Number"
Will wait for at most \f(CW$max_wait\fR seconds before checking port.
.Sp
See also Net::EmptyPort.
.Sp
\&\fIDefault: 10\fR
.RE
.RS 4
.RE
.ie n .IP "$server\->\fIstart()\fR" 4
.el .IP "\f(CW$server\fR\->\fIstart()\fR" 4
.IX Item "$server->start()"
Start the server process. Normally, you don't need to call this method.
.ie n .IP "$server\->\fIstop()\fR" 4
.el .IP "\f(CW$server\fR\->\fIstop()\fR" 4
.IX Item "$server->stop()"
Stop the server process.
.ie n .IP "my $pid = $server\->\fIpid()\fR;" 4
.el .IP "my \f(CW$pid\fR = \f(CW$server\fR\->\fIpid()\fR;" 4
.IX Item "my $pid = $server->pid();"
Get the pid of child process.
.ie n .IP "my $port = $server\->\fIport()\fR;" 4
.el .IP "my \f(CW$port\fR = \f(CW$server\fR\->\fIport()\fR;" 4
.IX Item "my $port = $server->port();"
Get the port number of child process.
.SH "FAQ"
.IX Header "FAQ"
.IP "How to invoke two servers?" 4
.IX Item "How to invoke two servers?"
You can call \fItest_tcp()\fR twice!
.Sp
.Vb 10
\&    test_tcp(
\&        client => sub {
\&            my $port1 = shift;
\&            test_tcp(
\&                client => sub {
\&                    my $port2 = shift;
\&                    # some client code here
\&                },
\&                server => sub {
\&                    my $port2 = shift;
\&                    # some server2 code here
\&                },
\&            );
\&        },
\&        server => sub {
\&            my $port1 = shift;
\&            # some server1 code here
\&        },
\&    );
.Ve
.Sp
Or use OO-ish interface instead.
.Sp
.Vb 8
\&    my $server1 = Test::TCP\->new(code => sub {
\&        my $port1 = shift;
\&        ...
\&    });
\&    my $server2 = Test::TCP\->new(code => sub {
\&        my $port2 = shift;
\&        ...
\&    });
\&
\&    # your client code here.
\&    ...
.Ve
.IP "How do you test server program written in other languages like memcached?" 4
.IX Item "How do you test server program written in other languages like memcached?"
You can use \f(CW\*(C`exec()\*(C'\fR in child process.
.Sp
.Vb 6
\&    use strict;
\&    use warnings;
\&    use utf8;
\&    use Test::More;
\&    use Test::TCP 1.08;
\&    use File::Which;
\&
\&    my $bin = scalar which \*(Aqmemcached\*(Aq;
\&    plan skip_all => \*(Aqmemcached binary is not found\*(Aq unless defined $bin;
\&
\&    my $memcached = Test::TCP\->new(
\&        code => sub {
\&            my $port = shift;
\&
\&            exec $bin, \*(Aq\-p\*(Aq => $port;
\&            die "cannot execute $bin: $!";
\&        },
\&    );
\&
\&    use Cache::Memcached;
\&    my $memd = Cache::Memcached\->new({servers => [\*(Aq127.0.0.1:\*(Aq . $memcached\->port]});
\&    $memd\->set(foo => \*(Aqbar\*(Aq);
\&    is $memd\->get(\*(Aqfoo\*(Aq), \*(Aqbar\*(Aq;
\&
\&    done_testing;
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Tokuhiro Matsuno <tokuhirom@gmail.com>
.SH "THANKS TO"
.IX Header "THANKS TO"
kazuhooku
.PP
dragon3
.PP
charsbar
.PP
Tatsuhiko Miyagawa
.PP
lestrrat
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.SH "LICENSE"
.IX Header "LICENSE"
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
