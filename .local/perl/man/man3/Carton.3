.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Carton 3"
.TH Carton 3 "2014-09-23" "perl v5.20.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Carton \- Perl module dependency manager (aka Bundler for Perl)
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&  # On your development environment
\&  > cat cpanfile
\&  requires \*(AqPlack\*(Aq, \*(Aq0.9980\*(Aq;
\&  requires \*(AqStarman\*(Aq, \*(Aq0.2000\*(Aq;
\&
\&  > carton install
\&  > git add cpanfile cpanfile.snapshot
\&  > git commit \-m "add Plack and Starman"
\&
\&  # Other developer\*(Aqs machine, or on a deployment box
\&  > carton install
\&  > carton exec starman \-p 8080 myapp.psgi
.Ve
.SH "AVAILABILITY"
.IX Header "AVAILABILITY"
Carton only works with perl installation with the complete set of core
modules. If you use perl installed by a vendor package with modules
stripped from core, Carton is not expected to work correctly.
.PP
Also, Carton requires you to run your command/application with
\&\f(CW\*(C`carton exec\*(C'\fR command, which means it's difficult or impossible to
run in an embedded perl use case such as mod_perl.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
carton is a command line tool to track the Perl module dependencies
for your Perl application. Dependencies are declared using cpanfile
format, and the managed dependencies are tracked in a
\&\fIcpanfile.snapshot\fR file, which is meant to be version controlled,
and the snapshot file allows other developers of your application will
have the exact same versions of the modules.
.PP
For \f(CW\*(C`cpanfile\*(C'\fR syntax, see cpanfile documentation.
.SH "TUTORIAL"
.IX Header "TUTORIAL"
.SS "Initializing the environment"
.IX Subsection "Initializing the environment"
carton will use the \fIlocal\fR directory to install modules into. You're
recommended to exclude these directories from the version control
system.
.PP
.Vb 3
\&  > echo local/ >> .gitignore
\&  > git add cpanfile cpanfile.snapshot
\&  > git commit \-m "Start using carton"
.Ve
.SS "Tracking the dependencies"
.IX Subsection "Tracking the dependencies"
You can manage the dependencies of your application via \f(CW\*(C`cpanfile\*(C'\fR.
.PP
.Vb 3
\&  # cpanfile
\&  requires \*(AqPlack\*(Aq, \*(Aq0.9980\*(Aq;
\&  requires \*(AqStarman\*(Aq, \*(Aq0.2000\*(Aq;
.Ve
.PP
And then you can install these dependencies via:
.PP
.Vb 1
\&  > carton install
.Ve
.PP
The modules are installed into your \fIlocal\fR directory, and the
dependencies tree and version information are analyzed and saved into
\&\fIcpanfile.snapshot\fR in your directory.
.PP
Make sure you add \fIcpanfile\fR and \fIcpanfile.snapshot\fR to your version
controlled repository and commit changes as you update
dependencies. This will ensure that other developers on your app, as
well as your deployment environment, use exactly the same versions of
the modules you just installed.
.PP
.Vb 2
\&  > git add cpanfile cpanfile.snapshot
\&  > git commit \-m "Added Plack and Starman"
.Ve
.SS "Deploying your application"
.IX Subsection "Deploying your application"
Once you've done installing all the dependencies, you can push your
application directory to a remote machine (excluding \fIlocal\fR and
\&\fI.carton\fR) and run the following command:
.PP
.Vb 1
\&  > carton install \-\-deployment
.Ve
.PP
This will look at the \fIcpanfile.snapshot\fR and install the exact same
versions of the dependencies into \fIlocal\fR, and now your application
is ready to run.
.PP
The \f(CW\*(C`\-\-deployment\*(C'\fR flag makes sure that carton will only install
modules and versions available in your snapshot, and won't fallback to
query for \s-1CPAN\s0 Meta \s-1DB\s0 for missing modules.
.SS "Bundling modules"
.IX Subsection "Bundling modules"
carton can bundle all the tarballs for your dependencies into a
directory so that you can even install dependencies that are not
available on \s-1CPAN,\s0 such as internal distribution aka DarkPAN.
.PP
.Vb 1
\&  > carton bundle
.Ve
.PP
will bundle these tarballs into \fIvendor/cache\fR directory, and
.PP
.Vb 1
\&  > carton install \-\-cached
.Ve
.PP
will install modules using this local cache. Combined with
\&\f(CW\*(C`\-\-deployment\*(C'\fR option, you can avoid querying for a database like
\&\s-1CPAN\s0 Meta \s-1DB\s0 or downloading files from \s-1CPAN\s0 mirrors upon deployment
time.
.SH "PERL VERSIONS"
.IX Header "PERL VERSIONS"
When you take a snapshot in one perl version and deploy on another
(different) version, you might have troubles with core modules.
.PP
The simplest solution, which might not work for everybody, is to use
the same version of perl in the development and deployment.
.PP
To enforce that, you're recommended to use plenv and
\&\f(CW\*(C`.perl\-version\*(C'\fR to lock perl versions in development.
.PP
You can also specify the minimum perl required in \f(CW\*(C`cpanfile\*(C'\fR:
.PP
.Vb 1
\&  requires \*(Aqperl\*(Aq, \*(Aq5.16.3\*(Aq;
.Ve
.PP
and carton (and cpanm) will give you errors when deployed on hosts
with perl lower than the specified version.
.SH "COMMUNITY"
.IX Header "COMMUNITY"
.IP "<https://github.com/miyagawa/carton>" 4
.IX Item "<https://github.com/miyagawa/carton>"
Code repository, Wiki and Issue Tracker
.IP "<irc://irc.perl.org/#carton>" 4
.IX Item "<irc://irc.perl.org/#carton>"
\&\s-1IRC\s0 chat room
.SH "AUTHOR"
.IX Header "AUTHOR"
Tatsuhiko Miyagawa
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Tatsuhiko Miyagawa 2011\-
.SH "LICENSE"
.IX Header "LICENSE"
This software is licensed under the same terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
cpanm
.PP
cpanfile
.PP
Bundler <http://gembundler.com/>
.PP
pip <http://pypi.python.org/pypi/pip>
.PP
npm <http://npmjs.org/>
.PP
perlrocks <https://github.com/gugod/perlrocks>
.PP
only
